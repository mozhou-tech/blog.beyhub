<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>二分法查找深入解析 | 采菊东篱</title><meta name="description" content="二分法是一种普通又重要的算法思想，二分搜索又称折半搜索，区别于线性查找O(n)的时间复杂度，二分法的时间复杂度降到了O(logN)。但二分法的使用也是有条件的，它要求原始序列具有单调性。本文会详细介绍二分法的前提、推论以及例题，力求深入浅出。"><meta property="og:type" content="article"><meta property="og:title" content="二分法查找深入解析"><meta property="og:url" content="https://blog.beyhub.com/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/index.html"><meta property="og:site_name" content="采菊东篱"><meta property="og:description" content="二分法是一种普通又重要的算法思想，二分搜索又称折半搜索，区别于线性查找O(n)的时间复杂度，二分法的时间复杂度降到了O(logN)。但二分法的使用也是有条件的，它要求原始序列具有单调性。本文会详细介绍二分法的前提、推论以及例题，力求深入浅出。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.beyhub.com/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/images/image-20220413180555294.png"><meta property="og:image" content="https://blog.beyhub.com/images/3-200623091020529.gif"><meta property="og:image" content="https://blog.beyhub.com/images/v2-37e8bdaa4c5137b4d3bab14f68ff08bb_720w.jpg"><meta property="og:image" content="https://blog.beyhub.com/images/3-200623093535Y7.gif"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726143530968-1723188378.png"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726143633812-1305883574.png"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726143710687-1584250871.png"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726143746265-1830805635.png"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726143823171-110597765.png"><meta property="og:image" content="https://blog.beyhub.com/images/16ab914cac222133~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://blog.beyhub.com/images/16ab914cad7cb5bf~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726165129453-1906239446.png"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726170324406-1007994414.png"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726170352562-425177951.png"><meta property="og:image" content="https://blog.beyhub.com/images/831179-20170726170529078-18287855.png"><meta property="article:published_time" content="2021-08-12T02:45:18.000Z"><meta property="article:modified_time" content="2022-04-14T02:43:20.449Z"><meta property="article:author" content="刘远程 (Lester Lau)"><meta property="article:tag" content="二分法"><meta property="article:tag" content="分治"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.beyhub.com/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/images/image-20220413180555294.png"><link rel="canonical" href="https://blog.beyhub.com/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/index.html"><link rel="alternate" href="/atom.xml" title="采菊东篱" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet"><meta name="generator" content="Hexo 5.4.0"></head><body class="main-center theme-purple" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="/about/"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">Lester Lau</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md" style="margin-top:13px;margin-bottom:6px">采菊东篱下，悠然见南山</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> NanJing, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">文章分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">常用网址</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于我</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/lesterlaucn" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/lyc90" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="https://twitter.com/lesterlaucn" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>Those who cannot remember the past are condemned to repeat it.<br>—George Santayana.</p></div></div></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/BPMN/" style="font-size:13px">BPMN</a> <a href="/tags/Go/" style="font-size:13px">Go</a> <a href="/tags/JVM/" style="font-size:13px">JVM</a> <a href="/tags/Java/" style="font-size:13.67px">Java</a> <a href="/tags/K3s/" style="font-size:13px">K3s</a> <a href="/tags/Kubernetes/" style="font-size:13px">Kubernetes</a> <a href="/tags/MySQL/" style="font-size:14px">MySQL</a> <a href="/tags/Proxy/" style="font-size:13px">Proxy</a> <a href="/tags/Spring/" style="font-size:13px">Spring</a> <a href="/tags/Traefik/" style="font-size:13px">Traefik</a> <a href="/tags/java/" style="font-size:13px">java</a> <a href="/tags/zookeeper/" style="font-size:13px">zookeeper</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size:13px">二分法</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size:13.33px">分布式</a> <a href="/tags/%E5%88%86%E6%B2%BB/" style="font-size:13px">分治</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size:13.33px">原理</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" style="font-size:13px">学习方法</a> <a href="/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/" style="font-size:13px">工作流</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size:13px">数据库</a> <a href="/tags/%E9%94%81/" style="font-size:13.67px">锁</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size:13px">高并发</a></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/">个人成长</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/">云原生</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-title"><a href="/post/go%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" class="title">Go语言深入浅出</a></p><p class="item-date"><time datetime="2022-04-13T01:15:21.000Z" itemprop="datePublished">2022-04-13</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/post/kubernetes%E5%AE%9E%E7%8E%B0traefik%E4%BB%A3%E7%90%86mysql%E6%B5%81%E9%87%8F/" class="title">Kubernetes实现Traefik代理MySQL流量</a></p><p class="item-date"><time datetime="2022-04-12T07:44:46.000Z" itemprop="datePublished">2022-04-12</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/post/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/" class="title">关系型数据库的单列索引与联合索引</a></p><p class="item-date"><time datetime="2021-08-21T19:51:02.000Z" itemprop="datePublished">2021-08-22</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" class="title">二分法查找深入解析</a></p><p class="item-date"><time datetime="2021-08-12T02:45:18.000Z" itemprop="datePublished">2021-08-12</time></p></div></li><li><div class="item-inner"><p class="item-title"><a href="/post/java-sdk%E4%B8%AD%E7%9A%84spi%E6%9C%BA%E5%88%B6/" class="title">Java SDK中的SPI机制</a></p><p class="item-date"><time datetime="2021-04-12T15:12:43.000Z" itemprop="datePublished">2021-04-12</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%E4%B8%8E%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">分治思想与二分法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">二分法的前提条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2"><span class="toc-number">1.4.</span> <span class="toc-text">线性搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="toc-number">1.5.1.</span> <span class="toc-text">二分搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.5.2.</span> <span class="toc-text">二分搜索树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E6%8E%A8%E5%B9%BF%E7%94%A8%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">二分法的推广用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%88%96%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E5%AE%8C%E6%88%90%E6%90%9C%E7%B4%A2"><span class="toc-number">1.6.1.</span> <span class="toc-text">在海量数据或数据流中完成搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%88%86%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.2.</span> <span class="toc-text">三分法与二分法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%8E%E8%B7%B3%E8%A1%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">二分法与跳表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.7.</span> <span class="toc-text">应用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDBMS%E4%B8%ADB-Tree%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">RDBMS中B-Tree索引的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.</span> <span class="toc-text">算法模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-leetcode-44"><span class="toc-number">2.1.</span> <span class="toc-text">搜索插入位置[leetcode 44]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81-leetcode-441"><span class="toc-number">2.2.</span> <span class="toc-text">排列硬币[leetcode 441]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-leetcode-69"><span class="toc-number">2.3.</span> <span class="toc-text">X的平方根[leetcode 69]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F-leetcode-374"><span class="toc-number">2.4.</span> <span class="toc-text">猜数字大小[leetcode 374]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-leetcode-162-%E4%B8%AD%E7%AD%89"><span class="toc-number">2.5.</span> <span class="toc-text">寻找峰值[leetcode 162 中等]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%BA%8F%E5%88%97%E8%BD%AC%E4%B8%BABST-leetcode-108"><span class="toc-number">2.5.1.</span> <span class="toc-text">有序数组序列转为BST[leetcode 108]</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-2021/二分法搜索" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">二分法查找深入解析</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" class="article-date"><time datetime="2021-08-12T02:45:18.000Z" itemprop="datePublished">2021-08-12</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" rel="tag">二分法</a>, <a class="article-tag-link-link" href="/tags/%E5%88%86%E6%B2%BB/" rel="tag">分治</a> </span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/#comments" class="article-comment-link">评论 </a></span><span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 2.8k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 11(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>二分法是一种普通又重要的算法思想，二分搜索又称折半搜索，区别于线性查找O(n)的时间复杂度，二分法的时间复杂度降到了O(logN)。但二分法的使用也是有条件的，它要求原始序列具有<code>单调性</code>。本文会详细介绍二分法的前提、推论以及例题，力求深入浅出。</p><img src="images/image-20220413180555294.png" alt="image-20220413180555294" style="zoom:50%"> <span id="more"></span><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="分治思想与二分法"><a href="#分治思想与二分法" class="headerlink" title="分治思想与二分法"></a>分治思想与二分法</h3><p>分治算法的主要思想是将原问题分成若干个子问题，解决这些子问题再最终合并出原问题的答案。在计算过程中，子问题会被递归地分解成更小的子问题，直到子问题满足边界条件。最后，算法会层层递回原问题的答案。</p><p><img src="/images/3-200623091020529.gif" alt="分治算法"></p><p>二分算法是比较一次，直接扔掉不符合要求的那一半。（如果中间的不行，则某一边一定不行）</p><p>分治不能这么做，它只是做了划分，并没有减小问题规模。（两边分别做，然后整体做一次，其中<strong>对整体的操作要求为O(n)复杂度</strong>才可以，<strong>一般要求两边都要有序，可以在归并排序的思路上更改</strong>）</p><h3 id="二分法的前提条件"><a href="#二分法的前提条件" class="headerlink" title="二分法的前提条件"></a>二分法的前提条件</h3><p>二分法只能在有序序列上使用。但有时候局部有序也是可以使用的，参考例题<code>寻找峰值</code>。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>二分法的每一次遍历都会排除一半的数据，这意味着搜索的目标数据集会迅速减小。</p><p>假设共有N个元素，每次查找的区间大小就是N，N&#x2F;2，N&#x2F;4，…，N&#x2F;2^k^（接下来操作元素的剩余个数），其中k就是循环的次数。<br>由于N&#x2F;2^k^取整后&gt;&#x3D;1，即令N&#x2F;2^2^&#x3D;1，可得k&#x3D;log2N,（是以2为底，N的对数）时间复杂度为O(logN)</p><h3 id="线性搜索"><a href="#线性搜索" class="headerlink" title="线性搜索"></a>线性搜索</h3><p>线性搜索或顺序搜索是一种寻找某一特定值的搜索算法，指按一定的顺序检查数组中每一个元素，直到找到所要寻找的特定值为止。是最简单的一种搜索算法。</p><p><img src="/images/v2-37e8bdaa4c5137b4d3bab14f68ff08bb_720w.jpg" alt="线性搜索linear Search - 知乎"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><p><img src="/images/3-200623093535Y7.gif" alt="二分查找"></p><h4 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h4><p>我们先来看二叉树查找时磁盘IO的次：定义一个树高为4的二叉树，查找值为10：</p><table><thead><tr><th>IO次数</th><th>示意图</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td><img src="/images/831179-20170726143530968-1723188378.png" alt="img"></td><td></td></tr><tr><td>1</td><td><img src="/images/831179-20170726143633812-1305883574.png" alt="img"></td><td></td></tr><tr><td>2</td><td><img src="/images/831179-20170726143710687-1584250871.png" alt="img"></td><td></td></tr><tr><td>3</td><td><img src="/images/831179-20170726143746265-1830805635.png" alt="img"></td><td></td></tr><tr><td>4</td><td><img src="/images/831179-20170726143823171-110597765.png" alt="img"></td><td></td></tr></tbody></table><p>从二叉树的查找过程了来看，树的高度和磁盘IO的次数都是4，所以最坏的情况下磁盘IO的次数由树的高度来决定。</p><p>从前面分析情况来看，<strong>减少磁盘IO的次数就必须要压缩树的高度</strong>，让瘦高的树尽量变成矮胖的树，所以B-Tree就在这样伟大的时代背景下诞生了。</p><h3 id="二分法的推广用法"><a href="#二分法的推广用法" class="headerlink" title="二分法的推广用法"></a>二分法的推广用法</h3><h4 id="在海量数据或数据流中完成搜索"><a href="#在海量数据或数据流中完成搜索" class="headerlink" title="在海量数据或数据流中完成搜索"></a>在海量数据或数据流中完成搜索</h4><p>在海量（长度不可知）的单调序列中，可以以一定的步长跳跃式的搜索。</p><p>例如在递增的序列中寻找值X，约定步长为10000，N次跳跃后发现比X大的值，此时在索引(N-1)*10000和N*10000之间进行二分法搜索。</p><h4 id="三分法与二分法的区别"><a href="#三分法与二分法的区别" class="headerlink" title="三分法与二分法的区别"></a>三分法与二分法的区别</h4><p>二分法适用于单调函数，而单峰函数用二分明显不太好了，对于有些单峰函数，可以求导后转化为单调函数，从而使用二分，然而很多情况求导是很麻烦的，这时就需要用到三分了。</p><p><strong>算法介绍</strong></p><ol><li><p>先将区间三分,每个区间的长度为1&#x2F;3(right-left)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mid1=left+(right-left)/<span class="number">3</span>;</span><br><span class="line">mid2=right-(right-left)/<span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>比较mid1和mid2谁更靠近极值，如果mid1更靠近极值，右区间改为mid2,否则左区间改为mid1(后面的代码都是 以求最大值为例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(calc(mid1)&lt;calc(mid2))</span><br><span class="line">	left=mid1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	right=mid2;</span><br></pre></td></tr></table></figure></li><li><p>重复1,2过程，直到不满足left+eps&lt;right,也就是找到最值</p></li></ol><p><strong>算法模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Calc</span><span class="params">(Type a)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 根据题目的意思计算 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Left, right;</span><br><span class="line">    <span class="keyword">double</span> mid, midmid;</span><br><span class="line">    <span class="keyword">double</span> mid_value, midmid_value;</span><br><span class="line">    left = min; right = max;</span><br><span class="line">    <span class="keyword">while</span> (left + eps &lt; Right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        midmid = (mid + right) / <span class="number">2</span>;</span><br><span class="line">        mid_area = Calc(mid);</span><br><span class="line">        midmid_area = Calc(midmid);</span><br><span class="line">        <span class="keyword">if</span> (mid_area &gt;= midmid_area) right = midmid;</span><br><span class="line">        <span class="keyword">else</span> left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分法与跳表"><a href="#二分法与跳表" class="headerlink" title="二分法与跳表"></a>二分法与跳表</h4><p>跳表的原理类似二分查找，但是数据结构用得链表，跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。理论有点抽象，下面也用个图来说明一下:</p><p><img src="/images/16ab914cac222133~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="skip_list"></p><p>上图例子中是使用了一个单链表实现的简单的跳表， Node类里next指向下一个节点, value是当前的值，图上面数字是节点中的值，索引的Node是一个指针, 指向原始的节点。 上图的链表数值依次是 2, 5 , 10, 12, 18 , 22, 25, 26。假如在链表中要找是否有12, 需要从单链表头开始遍历，到第4个就找到18。当建立了如上图的2层索引后，首先从第一层索引开始， 2 -&gt; 18 ， 18大于12不对，所以第二层索引 2 -&gt; 10 找到10的位置，然后10 -&gt;12 就找到了12。当数据量很大，查找的时间复杂度为O(logn)。图中索引是每隔一个节点建的索引(每隔1个相当于每次减半)，你也可以设计每隔3个节点建一个索引。索引层级也要根据数据量增加，单链表也可以改成双链表。</p><p>上面分析了跳表搜索的过程，接着聊聊数据插入过程，假如接下来要插入 6、7、 8、 9这几个元素，需要保持跳表节点顺序，可以利用索引找到第二层索引的中2 (第二层索引的10 大于 6, 7, 8 , 9)。插入元素后情况如下图所示：</p><p><img src="/images/16ab914cad7cb5bf~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="skip_list"></p><p>看上图所示，如果需要找9，你会发现查找速度下降，原因是由于插入数据导致原有索引性能退化啦，需要重新生成索引才能保证查找的速度。同样的，删除节点时通过索引快速找到需要删除的节点，删除后也同样需要维持新索引。创建索引会占据一定性能，在插入或者删除数据时，如果没插入或删除一个元素就重新创建索引又有点浪费，所以需要平衡一下，比如记录最底层的索引间的元素个数间隔，超过多少个再重新创建索引。</p><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="RDBMS中B-Tree索引的实现"><a href="#RDBMS中B-Tree索引的实现" class="headerlink" title="RDBMS中B-Tree索引的实现"></a>RDBMS中B-Tree索引的实现</h4><blockquote><p>m阶B-Tree满足以下条件：</p><ol><li>每个节点最多拥有m个子树</li><li>根节点至少有2个子树</li><li>分支节点至少拥有m&#x2F;2颗子树（除根节点和叶子节点外都是分支节点）</li><li>所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列</li></ol></blockquote><p>如下有一个3阶的B树，查找元素21的过程：</p><table><thead><tr><th>IO次数</th><th>示意图</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td><img src="/images/831179-20170726165129453-1906239446.png" alt="img"></td><td>查找元素21</td></tr><tr><td>1</td><td><img src="/images/831179-20170726170324406-1007994414.png" alt="img"></td><td></td></tr><tr><td>2</td><td><img src="/images/831179-20170726170352562-425177951.png" alt="img"></td><td>这里有一次内存比对：<code>21</code>分别跟3与12比对</td></tr><tr><td>3</td><td><img src="/images/831179-20170726170529078-18287855.png" alt="img"></td><td>这里有一次内存比对，<code>21</code>分别跟14与21比对</td></tr></tbody></table><p>从查找过程中发现，B树的比对次数和磁盘IO的次数与二叉树相差不了多少，所以这样看来并没有什么优势。</p><p>但是仔细一看会发现，<strong>比对是在内存中完成中，不涉及到磁盘IO，耗时可以忽略不计。另外B树中一个节点中可以存放很多的key（个数由树阶决定）。</strong></p><p><strong>相同数量的key在B树中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘IO的次数。这样到达一定数量后，性能的差异就显现出来了。</strong></p><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><h3 id="搜索插入位置-leetcode-44"><a href="#搜索插入位置-leetcode-44" class="headerlink" title="搜索插入位置[leetcode 44]"></a>搜索插入位置[leetcode 44]</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = nums.length;</span><br><span class="line">      <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// while灵活控制指针动作</span></span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left; <span class="comment">// 右移模拟2的整除运算</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">          right = mid - <span class="number">1</span>; <span class="comment">// ?</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          left = mid + <span class="number">1</span>; <span class="comment">// ?</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排列硬币-leetcode-441"><a href="#排列硬币-leetcode-441" class="headerlink" title="排列硬币[leetcode 441]"></a>排列硬币[leetcode 441]</h3><p>你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。</p><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/arranging-coins/solution/pai-lie-ying-bi-by-leetcode-solution-w52c/">https://leetcode-cn.com/problems/arranging-coins/solution/pai-lie-ying-bi-by-leetcode-solution-w52c/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="comment">// 总行数在1和硬币总块数之间</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left + <span class="number">1</span>) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="comment">// 注意等差数列的求和公式 Sn=n(a1+an)/2 </span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * (mid + <span class="number">1</span>) / <span class="number">2</span> &lt;= n) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="X的平方根-leetcode-69"><a href="#X的平方根-leetcode-69" class="headerlink" title="X的平方根[leetcode 69]"></a>X的平方根[leetcode 69]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = x, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="comment">// mid 小，</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span>) mid * mid &lt;= x) &#123;</span><br><span class="line">                res = mid;      <span class="comment">// 相当于向下取整</span></span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// mid本身排除在外</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// mid 本身排除在外</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="猜数字大小-leetcode-374"><a href="#猜数字大小-leetcode-374" class="headerlink" title="猜数字大小[leetcode 374]"></a>猜数字大小[leetcode 374]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (guess(n) == <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> flag = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; flag != <span class="number">0</span>) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            flag = guess(mid);</span><br><span class="line">            <span class="keyword">if</span> (flag == -<span class="number">1</span>) right = mid;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找峰值-leetcode-162-中等"><a href="#寻找峰值-leetcode-162-中等" class="headerlink" title="寻找峰值[leetcode 162 中等]"></a>寻找峰值[leetcode 162 中等]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">爬坡法</span></span><br><span class="line"><span class="comment">规律一：如果nums[i] &gt; nums[i+1]，则在i之前一定存在峰值元素</span></span><br><span class="line"><span class="comment">规律二：如果nums[i] &lt; nums[i+1]，则在i+1之后一定存在峰值元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">func <span class="title">findPeakElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> left &lt; right &#123; <span class="comment">// 为何不能取等？</span></span><br><span class="line">      mid := (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">      <span class="comment">// 如果num[mid] &gt; nums[mid+1] 左侧一定有峰值</span></span><br><span class="line">      <span class="keyword">if</span> nums[mid] &gt; nums[mid+<span class="number">1</span>] &#123;</span><br><span class="line">         right = mid</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         left = mid + <span class="number">1</span> </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序数组序列转为BST-leetcode-108"><a href="#有序数组序列转为BST-leetcode-108" class="headerlink" title="有序数组序列转为BST[leetcode 108]"></a>有序数组序列转为BST[leetcode 108]</h4><p>九成以上的二叉树问题都可以使用分治法解决！</p><p>中序遍历：左-&gt;根-&gt;右（中序遍历二叉搜索树等于遍历有序数组）</p><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(nums []<span class="keyword">int</span>, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 总是选择中间位置右边的数字作为根节点</span></span><br><span class="line">   mid := (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">   root := &amp;TreeNode&#123;Val: nums[mid]&#125;</span><br><span class="line">   root.Left = helper(nums, left, mid<span class="number">-1</span>)</span><br><span class="line">   root.Right = helper(nums, mid+<span class="number">1</span>, right)</span><br><span class="line">   <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903843990339597">https://juejin.cn/post/6844903843990339597</a></li><li><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></li></ol><link rel="stylesheet" href="/css/markmap.css" type="text/css"></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://blog.beyhub.com/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/" title="二分法查找深入解析" target="_blank" rel="external">https://blog.beyhub.com/post/二分法查找深入解析/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><hr></div></article><section id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/post/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/" title="关系型数据库的单列索引与联合索引"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/post/java-sdk%E4%B8%AD%E7%9A%84spi%E6%9C%BA%E5%88%B6/" title="Java SDK中的SPI机制"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/lesterlaucn" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/lyc90" target="_blank" title="Weibo" data-toggle="tooltip" data-placement="top"><i class="icon icon-weibo"></i></a></li><li><a href="https://twitter.com/lesterlaucn" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright">&copy; 2022 刘远程 (Lester Lau)<div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">me </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script defer>var disqus_config=function(){this.page.url="https://blog.beyhub.com/post/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/",this.page.identifier="2021/二分法搜索"};!function(){var t=document,e=t.createElement("script");e.src="//cai-ju-dong-li.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script><script>$(document).ready(function () {
      let imgs = $('article img');
      imgs.attr('src', '/' + imgs.attr('src'))
    }
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function () {
      $('article img').not('[hidden]').not('.panel-body img').each(function () {
        var $image = $(this);
        var imageCaption = $image.attr('alt');
        var $imageWrapLink = $image.parent('a');
        if ($imageWrapLink.length < 1) {
          var src = this.getAttribute('src');
          var idx = src.lastIndexOf('?');
          if (idx != -1) {
            src = src.substring(0, idx);
          }
          $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
        }
        $imageWrapLink.attr('data-fancybox', 'images');
        if (imageCaption) {
          $imageWrapLink.attr('data-caption', imageCaption);
        }
      });
      $().fancybox({
        selector: '[data-fancybox="images"]',
        hash: false,
        loop: false,
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/d3@5"></script><script src="https://cdn.jsdelivr.net/npm/markmap-lib@0.7.4/dist/browser/view.min.js"></script><script>const mindmaps=document.querySelectorAll(".markmap-svg");for(const a of mindmaps)markmap.markmap(a,JSON.parse(a.innerHTML))</script></body></html>